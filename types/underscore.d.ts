export = underscore;
declare class underscore {
  static VERSION: string;
  static after(times: any, func: any): any;
  static all(obj: any, iterator: any, context: any): any;
  static any(obj: any, iterator: any, context: any): any;
  static bind(func: any, context: any, ...args: any[]): any;
  static bindAll(obj: any, ...args: any[]): any;
  static chain(obj: any): any;
  static clone(obj: any): any;
  static collect(obj: any, iterator: any, context: any): any;
  static compact(array: any): any;
  static compose(...args: any[]): any;
  static contains(obj: any, target: any): any;
  static countBy(obj: any, value: any, context: any): any;
  static debounce(func: any, wait: any, immediate: any): any;
  static defaults(obj: any, ...args: any[]): any;
  static defer(func: any, ...args: any[]): any;
  static delay(func: any, wait: any, ...args: any[]): any;
  static detect(obj: any, iterator: any, context: any): any;
  static difference(array: any, ...args: any[]): any;
  static drop(array: any, n: any, guard: any): any;
  static each(obj: any, iterator: any, context: any): void;
  static escape(string: any): any;
  static every(obj: any, iterator: any, context: any): any;
  static extend(obj: any, ...args: any[]): any;
  static filter(obj: any, iterator: any, context: any): any;
  static find(obj: any, iterator: any, context: any): any;
  static findWhere(obj: any, attrs: any): any;
  static first(array: any, n: any, guard: any): any;
  static flatten(array: any, shallow: any): any;
  static foldl(obj: any, iterator: any, memo: any, context: any, ...args: any[]): any;
  static foldr(obj: any, iterator: any, memo: any, context: any, ...args: any[]): any;
  static forEach(obj: any, iterator: any, context: any): void;
  static functions(obj: any): any;
  static groupBy(obj: any, value: any, context: any): any;
  static has(obj: any, key: any): any;
  static head(array: any, n: any, guard: any): any;
  static identity(value: any): any;
  static include(obj: any, target: any): any;
  static indexBy(obj: any, value: any, context: any): any;
  static indexOf(array: any, item: any, isSorted: any): any;
  static initial(array: any, n: any, guard: any): any;
  static inject(obj: any, iterator: any, memo: any, context: any, ...args: any[]): any;
  static intersection(array: any, ...args: any[]): any;
  static invert(obj: any): any;
  static invoke(obj: any, method: any, ...args: any[]): any;
  static isArguments(obj: any): any;
  static isArray(p0: any): any;
  static isBoolean(obj: any): any;
  static isDate(obj: any): any;
  static isElement(obj: any): any;
  static isEmpty(obj: any): any;
  static isEqual(a: any, b: any): any;
  static isFinite(obj: any): any;
  static isFunction(obj: any): any;
  static isNaN(obj: any): any;
  static isNull(obj: any): any;
  static isNumber(obj: any): any;
  static isObject(obj: any): any;
  static isRegExp(obj: any): any;
  static isString(obj: any): any;
  static isUndefined(obj: any): any;
  static keys(p0: any): any;
  static last(array: any, n: any, guard: any): any;
  static lastIndexOf(array: any, item: any, from: any): any;
  static map(obj: any, iterator: any, context: any): any;
  static max(obj: any, iterator: any, context: any): any;
  static memoize(func: any, hasher: any): any;
  static methods(obj: any): any;
  static min(obj: any, iterator: any, context: any): any;
  static mixin(obj: any): void;
  static noConflict(): any;
  static object(list: any, values: any): any;
  static omit(obj: any, ...args: any[]): any;
  static once(func: any): any;
  static pairs(obj: any): any;
  static partial(func: any, ...args: any[]): any;
  static pick(obj: any, ...args: any[]): any;
  static pluck(obj: any, key: any): any;
  static random(min: any, max: any): any;
  static range(start: any, stop: any, step: any, ...args: any[]): any;
  static reduce(obj: any, iterator: any, memo: any, context: any, ...args: any[]): any;
  static reduceRight(obj: any, iterator: any, memo: any, context: any, ...args: any[]): any;
  static reject(obj: any, iterator: any, context: any): any;
  static rest(array: any, n: any, guard: any): any;
  static result(object: any, property: any): any;
  static sample(obj: any, n: any, guard: any, ...args: any[]): any;
  static select(obj: any, iterator: any, context: any): any;
  static shuffle(obj: any): any;
  static size(obj: any): any;
  static some(obj: any, iterator: any, context: any): any;
  static sortBy(obj: any, value: any, context: any): any;
  static sortedIndex(array: any, obj: any, iterator: any, context: any): any;
  static tail(array: any, n: any, guard: any): any;
  static take(array: any, n: any, guard: any): any;
  static tap(obj: any, interceptor: any): any;
  static template(text: any, data: any, settings: any): any;
  static templateSettings: {
    escape: RegExp;
    evaluate: RegExp;
    interpolate: RegExp;
  };
  static throttle(func: any, wait: any, options: any): any;
  static times(n: any, iterator: any, context: any): any;
  static toArray(obj: any): any;
  static unescape(string: any): any;
  static union(...args: any[]): any;
  static uniq(array: any, isSorted: any, iterator: any, context: any): any;
  static unique(array: any, isSorted: any, iterator: any, context: any): any;
  static uniqueId(prefix: any): any;
  static values(obj: any): any;
  static where(obj: any, attrs: any, first: any): any;
  static without(array: any, ...args: any[]): any;
  static wrap(func: any, wrapper: any): any;
  static zip(...args: any[]): any;
  constructor(obj: any);
  after(...args: any[]): any;
  all(...args: any[]): any;
  any(...args: any[]): any;
  bind(...args: any[]): any;
  bindAll(...args: any[]): any;
  chain(): any;
  clone(...args: any[]): any;
  collect(...args: any[]): any;
  compact(...args: any[]): any;
  compose(...args: any[]): any;
  concat(...args: any[]): any;
  contains(...args: any[]): any;
  countBy(...args: any[]): any;
  debounce(...args: any[]): any;
  defaults(...args: any[]): any;
  defer(...args: any[]): any;
  delay(...args: any[]): any;
  detect(...args: any[]): any;
  difference(...args: any[]): any;
  drop(...args: any[]): any;
  each(...args: any[]): any;
  escape(...args: any[]): any;
  every(...args: any[]): any;
  extend(...args: any[]): any;
  filter(...args: any[]): any;
  find(...args: any[]): any;
  findWhere(...args: any[]): any;
  first(...args: any[]): any;
  flatten(...args: any[]): any;
  foldl(...args: any[]): any;
  foldr(...args: any[]): any;
  forEach(...args: any[]): any;
  functions(...args: any[]): any;
  groupBy(...args: any[]): any;
  has(...args: any[]): any;
  head(...args: any[]): any;
  identity(...args: any[]): any;
  include(...args: any[]): any;
  indexBy(...args: any[]): any;
  indexOf(...args: any[]): any;
  initial(...args: any[]): any;
  inject(...args: any[]): any;
  intersection(...args: any[]): any;
  invert(...args: any[]): any;
  invoke(...args: any[]): any;
  isArguments(...args: any[]): any;
  isArray(...args: any[]): any;
  isBoolean(...args: any[]): any;
  isDate(...args: any[]): any;
  isElement(...args: any[]): any;
  isEmpty(...args: any[]): any;
  isEqual(...args: any[]): any;
  isFinite(...args: any[]): any;
  isFunction(...args: any[]): any;
  isNaN(...args: any[]): any;
  isNull(...args: any[]): any;
  isNumber(...args: any[]): any;
  isObject(...args: any[]): any;
  isRegExp(...args: any[]): any;
  isString(...args: any[]): any;
  isUndefined(...args: any[]): any;
  join(...args: any[]): any;
  keys(...args: any[]): any;
  last(...args: any[]): any;
  lastIndexOf(...args: any[]): any;
  map(...args: any[]): any;
  max(...args: any[]): any;
  memoize(...args: any[]): any;
  methods(...args: any[]): any;
  min(...args: any[]): any;
  mixin(...args: any[]): any;
  noConflict(...args: any[]): any;
  object(...args: any[]): any;
  omit(...args: any[]): any;
  once(...args: any[]): any;
  pairs(...args: any[]): any;
  partial(...args: any[]): any;
  pick(...args: any[]): any;
  pluck(...args: any[]): any;
  pop(...args: any[]): any;
  push(...args: any[]): any;
  random(...args: any[]): any;
  range(...args: any[]): any;
  reduce(...args: any[]): any;
  reduceRight(...args: any[]): any;
  reject(...args: any[]): any;
  rest(...args: any[]): any;
  result(...args: any[]): any;
  reverse(...args: any[]): any;
  sample(...args: any[]): any;
  select(...args: any[]): any;
  shift(...args: any[]): any;
  shuffle(...args: any[]): any;
  size(...args: any[]): any;
  slice(...args: any[]): any;
  some(...args: any[]): any;
  sort(...args: any[]): any;
  sortBy(...args: any[]): any;
  sortedIndex(...args: any[]): any;
  splice(...args: any[]): any;
  tail(...args: any[]): any;
  take(...args: any[]): any;
  tap(...args: any[]): any;
  template(...args: any[]): any;
  throttle(...args: any[]): any;
  times(...args: any[]): any;
  toArray(...args: any[]): any;
  unescape(...args: any[]): any;
  union(...args: any[]): any;
  uniq(...args: any[]): any;
  unique(...args: any[]): any;
  uniqueId(...args: any[]): any;
  unshift(...args: any[]): any;
  value(): any;
  values(...args: any[]): any;
  where(...args: any[]): any;
  without(...args: any[]): any;
  wrap(...args: any[]): any;
  zip(...args: any[]): any;
}
