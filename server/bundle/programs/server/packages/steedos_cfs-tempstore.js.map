{"version":3,"sources":["meteor://ðŸ’»app/packages/steedos:cfs-tempstore/checkNpm.js","meteor://ðŸ’»app/packages/steedos:cfs-tempstore/tempStore.js"],"names":["checkNpmVersions","module","link","v","EventEmitter","require","CombinedStream","FS","TempStore","tracker","Tracker","Mongo","Collection","Storage","mountStorage","Package","Store","GridFS","internal","FileSystem","Error","debug","console","log","typeName","mountFile","fileObj","name","isMounted","on","chunkNum","count","total","result","_chunkPath","n","_fileReference","chunk","existing","findOne","fileId","_id","collectionName","tempFileObj","File","original","copies","_tempstore","key","keys","adapter","fileKey","exists","listParts","fsTempStoreListParts","self","warn","removeFile","fsTempStoreRemoveFile","emit","chunkInfo","Utility","each","remove","noop","removeAll","fsTempStoreRemoveAll","find","forEach","createWriteStream","options","selector","chunkSum","upsert","$setOnInsert","isOnePart","isMultiPart","isStoreSync","writeStream","safeOn","setObj","update","$set","chunkCount","size","modifier","$unset","chunkSize","uploadedAt","Date","synchronizedAt","eventName","error","createReadStream","totalChunks","getNextStreamFunc","Meteor","bindEnvironment","next","chunkReadStream","combinedStream","create","currentChunk","append"],"mappings":"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","file":"/packages/steedos_cfs-tempstore.js","sourcesContent":["import { checkNpmVersions } from 'meteor/tmeasday:check-npm-versions';\r\ncheckNpmVersions({\r\n\t'combined-stream': '0.0.4'\r\n}, 'steedos:cfs-tempstore');","// ##Temporary Storage\r\n//\r\n// Temporary storage is used for chunked uploads until all chunks are received\r\n// and all copies have been made or given up. In some cases, the original file\r\n// is stored only in temporary storage (for example, if all copies do some\r\n// manipulation in beforeSave). This is why we use the temporary file as the\r\n// basis for each saved copy, and then remove it after all copies are saved.\r\n//\r\n// Every chunk is saved as an individual temporary file. This is safer than\r\n// attempting to write multiple incoming chunks to different positions in a\r\n// single temporary file, which can lead to write conflicts.\r\n//\r\n// Using temp files also allows us to easily resume uploads, even if the server\r\n// restarts, and to keep the working memory clear.\r\n\r\n// The FS.TempStore emits events that others are able to listen to\r\nvar EventEmitter = require('events').EventEmitter;\r\n\r\n// We have a special stream concating all chunk files into one readable stream\r\nvar CombinedStream = require('combined-stream');\r\n\r\n/** @namespace FS.TempStore\r\n * @property FS.TempStore\r\n * @type {object}\r\n * @public\r\n * *it's an event emitter*\r\n */\r\nFS.TempStore = new EventEmitter();\r\n\r\n// Create a tracker collection for keeping track of all chunks for any files that are currently in the temp store\r\nvar tracker = FS.TempStore.Tracker = new Mongo.Collection('cfs._tempstore.chunks');\r\n\r\n/**\r\n * @property FS.TempStore.Storage\r\n * @type {StorageAdapter}\r\n * @namespace FS.TempStore\r\n * @private\r\n * This property is set to either `FS.Store.FileSystem` or `FS.Store.GridFS`\r\n *\r\n * __When and why:__\r\n * We normally default to `cfs-filesystem` unless its not installed. *(we default to gridfs if installed)*\r\n * But if `cfs-gridfs` and `cfs-worker` is installed we default to `cfs-gridfs`\r\n *\r\n * If `cfs-gridfs` and `cfs-filesystem` is not installed we log a warning.\r\n * the user can set `FS.TempStore.Storage` them selfs eg.:\r\n * ```js\r\n *   // Its important to set `internal: true` this lets the SA know that we\r\n *   // are using this internally and it will give us direct SA api\r\n *   FS.TempStore.Storage = new FS.Store.GridFS('_tempstore', { internal: true });\r\n * ```\r\n *\r\n * > Note: This is considered as `advanced` use, its not a common pattern.\r\n */\r\nFS.TempStore.Storage = null;\r\n\r\n// We will not mount a storage adapter until needed. This allows us to check for the\r\n// existance of FS.FileWorker, which is loaded after this package because it\r\n// depends on this package.\r\nfunction mountStorage() {\r\n\r\n  if (FS.TempStore.Storage) return;\r\n\r\n  // XXX: We could replace this test, testing the FS scope for grifFS etc.\r\n  // This is on the todo later when we get \"stable\"\r\n  if (Package[\"steedos:cfs-gridfs\"] && (Package[\"steedos:cfs-worker\"] || !Package[\"steedos:cfs-filesystem\"])) {\r\n    // If the file worker is installed we would prefer to use the gridfs sa\r\n    // for scalability. We also default to gridfs if filesystem is not found\r\n\r\n    // Use the gridfs\r\n    FS.TempStore.Storage = new FS.Store.GridFS('_tempstore', { internal: true });\r\n  } else if (Package[\"steedos:cfs-filesystem\"]) {\r\n\r\n    // use the Filesystem\r\n    FS.TempStore.Storage = new FS.Store.FileSystem('_tempstore', { internal: true });\r\n  } else {\r\n    throw new Error('FS.TempStore.Storage is not set: Install steedos:cfs-filesystem or steedos:cfs-gridfs or set it manually');\r\n  }\r\n\r\n  FS.debug && console.log('TempStore is mounted on', FS.TempStore.Storage.typeName);\r\n}\r\n\r\nfunction mountFile(fileObj, name) {\r\n  if (!fileObj.isMounted()) {\r\n    throw new Error(name + ' cannot work with unmounted file');\r\n  }\r\n}\r\n\r\n// We update the fileObj on progress\r\nFS.TempStore.on('progress', function(fileObj, chunkNum, count, total, result) {\r\n  FS.debug && console.log('TempStore progress: Received ' + count + ' of ' + total + ' chunks for ' + fileObj.name());\r\n});\r\n\r\n// XXX: TODO\r\n// FS.TempStore.on('stored', function(fileObj, chunkCount, result) {\r\n//   // This should work if we pass on result from the SA on stored event...\r\n//   fileObj.update({ $set: { chunkSum: 1, chunkCount: chunkCount, size: result.size } });\r\n// });\r\n\r\n// Stream implementation\r\n\r\n/**\r\n * @method _chunkPath\r\n * @private\r\n * @param {Number} [n] Chunk number\r\n * @returns {String} Chunk naming convention\r\n */\r\n_chunkPath = function(n) {\r\n  return (n || 0) + '.chunk';\r\n};\r\n\r\n/**\r\n * @method _fileReference\r\n * @param {FS.File} fileObj\r\n * @param {Number} chunk\r\n * @private\r\n * @returns {String} Generated SA specific fileKey for the chunk\r\n *\r\n * Note: Calling function should call mountStorage() first, and\r\n * make sure that fileObj is mounted.\r\n */\r\n_fileReference = function(fileObj, chunk, existing) {\r\n  // Maybe it's a chunk we've already saved\r\n  existing = existing || tracker.findOne({fileId: fileObj._id, collectionName: fileObj.collectionName});\r\n\r\n  // Make a temporary fileObj just for fileKey generation\r\n  var tempFileObj = new FS.File({\r\n    collectionName: fileObj.collectionName,\r\n    _id: fileObj._id,\r\n    original: {\r\n      name: _chunkPath(chunk)\r\n    },\r\n    copies: {\r\n      _tempstore: {\r\n        key: existing && existing.keys[chunk]\r\n      }\r\n    }\r\n  });\r\n\r\n  // Return a fitting fileKey SA specific\r\n  return FS.TempStore.Storage.adapter.fileKey(tempFileObj);\r\n};\r\n\r\n/**\r\n * @method FS.TempStore.exists\r\n * @param {FS.File} File object\r\n * @returns {Boolean} Is this file, or parts of it, currently stored in the TempStore\r\n */\r\nFS.TempStore.exists = function(fileObj) {\r\n  var existing = tracker.findOne({fileId: fileObj._id, collectionName: fileObj.collectionName});\r\n  return !!existing;\r\n};\r\n\r\n/**\r\n * @method FS.TempStore.listParts\r\n * @param {FS.File} fileObj\r\n * @returns {Object} of parts already stored\r\n * @todo This is not yet implemented, milestone 1.1.0\r\n */\r\nFS.TempStore.listParts = function fsTempStoreListParts(fileObj) {\r\n  var self = this;\r\n  console.warn('This function is not correctly implemented using SA in TempStore');\r\n  //XXX This function might be necessary for resume. Not currently supported.\r\n};\r\n\r\n/**\r\n * @method FS.TempStore.removeFile\r\n * @public\r\n * @param {FS.File} fileObj\r\n * This function removes the file from tempstorage - it cares not if file is\r\n * already removed or not found, goal is reached anyway.\r\n */\r\nFS.TempStore.removeFile = function fsTempStoreRemoveFile(fileObj) {\r\n  var self = this;\r\n\r\n  // Ensure that we have a storage adapter mounted; if not, throw an error.\r\n  mountStorage();\r\n\r\n  // If fileObj is not mounted or can't be, throw an error\r\n  mountFile(fileObj, 'FS.TempStore.removeFile');\r\n\r\n  // Emit event\r\n  self.emit('remove', fileObj);\r\n\r\n  var chunkInfo = tracker.findOne({\r\n    fileId: fileObj._id,\r\n    collectionName: fileObj.collectionName\r\n  });\r\n\r\n  if (chunkInfo) {\r\n\r\n    // Unlink each file\r\n    FS.Utility.each(chunkInfo.keys || {}, function (key, chunk) {\r\n      var fileKey = _fileReference(fileObj, chunk, chunkInfo);\r\n      FS.TempStore.Storage.adapter.remove(fileKey, FS.Utility.noop);\r\n    });\r\n\r\n    // Remove fileObj from tracker collection, too\r\n    tracker.remove({_id: chunkInfo._id});\r\n\r\n  }\r\n};\r\n\r\n/**\r\n * @method FS.TempStore.removeAll\r\n * @public\r\n * This function removes all files from tempstorage - it cares not if file is\r\n * already removed or not found, goal is reached anyway.\r\n */\r\nFS.TempStore.removeAll = function fsTempStoreRemoveAll() {\r\n  var self = this;\r\n\r\n  // Ensure that we have a storage adapter mounted; if not, throw an error.\r\n  mountStorage();\r\n\r\n  tracker.find().forEach(function (chunkInfo) {\r\n    // Unlink each file\r\n    FS.Utility.each(chunkInfo.keys || {}, function (key, chunk) {\r\n      var fileKey = _fileReference({_id: chunkInfo.fileId, collectionName: chunkInfo.collectionName}, chunk, chunkInfo);\r\n      FS.TempStore.Storage.adapter.remove(fileKey, FS.Utility.noop);\r\n    });\r\n\r\n    // Remove from tracker collection, too\r\n    tracker.remove({_id: chunkInfo._id});\r\n  });\r\n};\r\n\r\n/**\r\n * @method FS.TempStore.createWriteStream\r\n * @public\r\n * @param {FS.File} fileObj File to store in temporary storage\r\n * @param {Number | String} [options]\r\n * @returns {Stream} Writeable stream\r\n *\r\n * `options` of different types mean differnt things:\r\n * * `undefined` We store the file in one part\r\n * *(Normal server-side api usage)*\r\n * * `Number` the number is the part number total\r\n * *(multipart uploads will use this api)*\r\n * * `String` the string is the name of the `store` that wants to store file data\r\n * *(stores that want to sync their data to the rest of the files stores will use this)*\r\n *\r\n * > Note: fileObj must be mounted on a `FS.Collection`, it makes no sense to store otherwise\r\n */\r\nFS.TempStore.createWriteStream = function(fileObj, options) {\r\n  var self = this;\r\n\r\n  // Ensure that we have a storage adapter mounted; if not, throw an error.\r\n  mountStorage();\r\n\r\n  // If fileObj is not mounted or can't be, throw an error\r\n  mountFile(fileObj, 'FS.TempStore.createWriteStream');\r\n\r\n  // Cache the selector for use multiple times below\r\n  var selector = {fileId: fileObj._id, collectionName: fileObj.collectionName};\r\n\r\n  // TODO, should pass in chunkSum so we don't need to use FS.File for it\r\n  var chunkSum = fileObj.chunkSum || 1;\r\n\r\n  // Add fileObj to tracker collection\r\n  tracker.upsert(selector, {$setOnInsert: {keys: {}}});\r\n\r\n  // Determine how we're using the writeStream\r\n  var isOnePart = false, isMultiPart = false, isStoreSync = false, chunkNum = 0;\r\n  if (options === +options) {\r\n    isMultiPart = true;\r\n    chunkNum = options;\r\n  } else if (options === ''+options) {\r\n    isStoreSync = true;\r\n  } else {\r\n    isOnePart = true;\r\n  }\r\n\r\n  // XXX: it should be possible for a store to sync by storing data into the\r\n  // tempstore - this could be done nicely by setting the store name as string\r\n  // in the chunk variable?\r\n  // This store name could be passed on the the fileworker via the uploaded\r\n  // event\r\n  // So the uploaded event can return:\r\n  // undefined - if data is stored into and should sync out to all storage adapters\r\n  // number - if a chunk has been uploaded\r\n  // string - if a storage adapter wants to sync its data to the other SA's\r\n\r\n  // Find a nice location for the chunk data\r\n  var fileKey = _fileReference(fileObj, chunkNum);\r\n\r\n  // Create the stream as Meteor safe stream\r\n  var writeStream = FS.TempStore.Storage.adapter.createWriteStream(fileKey);\r\n\r\n  // When the stream closes we update the chunkCount\r\n  writeStream.safeOn('stored', function(result) {\r\n    // Save key in tracker document\r\n    var setObj = {};\r\n    setObj['keys.' + chunkNum] = result.fileKey;\r\n    tracker.update(selector, {$set: setObj});\r\n\r\n    // Get updated chunkCount\r\n    var chunkCount = FS.Utility.size(tracker.findOne(selector).keys);\r\n\r\n    // Progress\r\n    self.emit('progress', fileObj, chunkNum, chunkCount, chunkSum, result);\r\n\r\n    // If upload is completed\r\n    if (chunkCount === chunkSum) {\r\n      // We no longer need the chunk info\r\n      var modifier = { $set: {}, $unset: {chunkCount: 1, chunkSum: 1, chunkSize: 1} };\r\n\r\n      // Check if the file has been uploaded before\r\n      if (typeof fileObj.uploadedAt === 'undefined') {\r\n        // We set the uploadedAt date\r\n        modifier.$set.uploadedAt = new Date();\r\n      } else {\r\n        // We have been uploaded so an event were file data is updated is\r\n        // called synchronizing - so this must be a synchronizedAt?\r\n        modifier.$set.synchronizedAt = new Date();\r\n      }\r\n\r\n      // Update the fileObject\r\n      fileObj.update(modifier);\r\n\r\n      // Fire ending events\r\n      var eventName = isStoreSync ? 'synchronized' : 'stored';\r\n      self.emit(eventName, fileObj, result);\r\n\r\n      // XXX is emitting \"ready\" necessary?\r\n      self.emit('ready', fileObj, chunkCount, result);\r\n    } else {\r\n      // Update the chunkCount on the fileObject\r\n      fileObj.update({ $set: {chunkCount: chunkCount} });\r\n    }\r\n  });\r\n\r\n  // Emit errors\r\n  writeStream.on('error', function (error) {\r\n    FS.debug && console.log('TempStore writeStream error:', error);\r\n    self.emit('error', error, fileObj);\r\n  });\r\n\r\n  return writeStream;\r\n};\r\n\r\n/**\r\n  * @method FS.TempStore.createReadStream\r\n  * @public\r\n  * @param {FS.File} fileObj The file to read\r\n  * @return {Stream} Returns readable stream\r\n  *\r\n  */\r\nFS.TempStore.createReadStream = function(fileObj) {\r\n  // Ensure that we have a storage adapter mounted; if not, throw an error.\r\n  mountStorage();\r\n\r\n  // If fileObj is not mounted or can't be, throw an error\r\n  mountFile(fileObj, 'FS.TempStore.createReadStream');\r\n\r\n  FS.debug && console.log('FS.TempStore creating read stream for ' + fileObj._id);\r\n\r\n  // Determine how many total chunks there are from the tracker collection\r\n  var chunkInfo = tracker.findOne({fileId: fileObj._id, collectionName: fileObj.collectionName}) || {};\r\n  var totalChunks = FS.Utility.size(chunkInfo.keys);\r\n\r\n  function getNextStreamFunc(chunk) {\r\n    return Meteor.bindEnvironment(function(next) {\r\n      var fileKey = _fileReference(fileObj, chunk);\r\n      var chunkReadStream = FS.TempStore.Storage.adapter.createReadStream(fileKey);\r\n      next(chunkReadStream);\r\n    }, function (error) {\r\n      throw error;\r\n    });\r\n  }\r\n\r\n  // Make a combined stream\r\n  var combinedStream = CombinedStream.create();\r\n\r\n  // Add each chunk stream to the combined stream when the previous chunk stream ends\r\n  var currentChunk = 0;\r\n  for (var chunk = 0; chunk < totalChunks; chunk++) {\r\n    combinedStream.append(getNextStreamFunc(chunk));\r\n  }\r\n\r\n  // Return the combined stream\r\n  return combinedStream;\r\n};\r\n"]}